# 课程简介

## 0x00 课程特点

### 1.知识点

- 线程安全
- 线程封闭
- 线程调度
- 同步容器
- 并发容器
- AQS
- J.U.C

### 2.高并发解决问题思路与手段

- 扩容
- 缓存
- 队列
- 拆分
- 服务降级与熔断
- 数据库切库
- 分库分表

![5bbe20c333aaf4a0d370daccce2e576b.png](en-resource://database/1376:1)

![159b775c10f4ee5525079e86168d28f6.png](en-resource://database/1378:1)

![35c406df5609dba5f25ba4463ad10fad.png](en-resource://database/1380:1)

## 0x01 并发

> `并发`：同时拥有两个或者多个线程，如果程序再单核处理器上运行，多个线程将交替地换入或者换出内存，这些线程同时“存在”的，每个线程都处于执行过程中的某个状态，如果运行再多核处理器上，此时，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行

> `高并发`：高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够 **同时并行处理** 很多请求。

- 并发：多个线程操作相同的资源，保证线程安全，合理使用资源。
- 高并发：服务能同时处理很多请求，提高程序性能。

## 0x02 知识技能

- 总体架构： Spring Boot，Maven，JDK8，MySQL
- 基础组件：MyBatis，Guava，Lombok，Redis，Kafka
- 高级组件：Joda-Time，Atomic包，J.U.C，AQS，ThreadLocal，RateLimiter，Hystrix，ThreadPool，ShardBatis，Curator，Elastic-job...

## 0x03 并发编程的基础

### CPU多级缓存

![59a311252480fbc028743fdf51900761.png](en-resource://database/1382:1)

**1.为什么需要CPU cache？** 
CPU的频率太快了，快到主存跟不上，这样再处理器时钟周期内，CPU常常需要等待主存，浪费资源。所以cache的出现，是为了缓解CPU和内存之间速度的不匹配问题（结构：cpu -> cache -> memory）.

**2.CPU cache有什么意义？**
1）时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问。
2）空间局部性：如果莫格数据被访问，那么与它相邻的数据很快也可能被访问；

### CPU多级缓存 - 缓存一致性（MESI）

- 用于保证多个CPU cache之间缓存共享数据的一致

![d481de10d3a718ecbf12e4d0888ace7b.png](en-resource://database/1386:1)

M：modified：
E：独享的
S：shared
I：无效的

### CPU多级缓存 - 乱序执行优化

- 处理器为提高运算速度而做出违背代码原有顺序的优化

![aa3f6de2afd1e294c8f74653c0fa88a4.png](en-resource://database/1388:1)

### Java内存模型（Java Memory Model, JMM)

![f894c2a82ee3f490b5f89b689768d2b4.png](en-resource://database/1390:1)

- 规范了Java虚拟机与计算机内存是如何协同工作的
- 规定了一个线程如何和何时才可以看到其他线程修改后的共享变量的值，以及在必须时如何同步的访问共享变量

堆：动态创建申请内存，有GC销毁对象，因为动态申请所以存取速度较慢
栈：内存生命周期一开始就确定，存取效率仅次于寄存器。
两个线程同时调用一个对象，就会获取它的成员变量，都有这个成员变量的私有拷贝。

![bbeba1f6bea34bd5b95deb44bc2e6abc.png](en-resource://database/1392:1)

![a9f43ee4e94634a5bbf2caa2062dd536.png](en-resource://database/1394:1)

![f6f03d9e2d1e543123dee21c92a081da.png](en-resource://database/1396:1)


### Java内存模型 - 同步八种操作

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态
- unlock（解锁）：作用于主内存的标量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
- write（写入）：作用于主内存的变量，他把store操作从工作内存中一个变量的值传送到主内存的变量中

### Java内存模型 - 同步规则

- 如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存，就要按顺序的执行store和write操作。但Java内存模型只要求上述操作必须按照顺序执行，而没有保证必须是连续执行
- 不允许read和load，store和write操作之一单独出现
- 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中
- 不允许一个线程无原因的（没有发生过任何assign操作）把数据从工作内存同步到主内存中
- 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新之情load或assign操作初始化变量的值
- 如果一个变量实现没有被lock操作锁定，则不润许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行Store和write操作）

### Java内存模型 - 同步操作与规则

![60c945d4b77d528c8131a6394671f053.png](en-resource://database/1398:1)

### 并发的优势与风险

![b6b7a1c287933f07d96b2ab916ac2e23.png](en-resource://database/1400:0)

### 总结

- CPU多级缓存：缓存一致性，乱序执行优化
- Java内存模型：JMM规定，抽象结构，同步八种操作及规则
- Java并发的优势与风险